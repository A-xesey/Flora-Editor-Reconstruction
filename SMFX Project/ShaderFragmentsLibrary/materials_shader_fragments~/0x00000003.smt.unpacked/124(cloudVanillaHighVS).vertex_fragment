vertexFragment cloudVanillaHighVS
	input normal color color1 position
	output color position -texcoords 3 float4

	declareCode
		extern uniform float4 gameInfo;
		extern uniform float4x4 worldToClip;
		extern uniform float4x3 worldToCamera;
		extern uniform float3x4 cameraToWorldTranspose;
		extern uniform struct
		{
		float4 vSunDir;
		float4 waterColor;
		float4 innerParms;
		float4 vCamPos;
		float4 sphereParms;
		float4 camParms;
		float4 illumParms;
		float4 fogParms;
		float4 nightLightTint;
		float4 nightLightColor;
		float4 duskLightColor;
		float4 dayLightColor;
		float4 nightShadowColor;
		float4 duskShadowColor;
		float4 dayShadowColor;
		float4 duskDawnStartEnd;
		float4x4 viewTransform;
		} terrainState;
		extern uniform float4x4 viewTransform;
		extern uniform float4 terraformValues;
		extern uniform float4 worldCameraNormal;
		extern uniform float4 customParams[1];
		extern uniform float4 foggingCPU;

		half ramp( half min, half max, half value )
		{
		return saturate( ( value - min ) / ( max - min ) );
		}
		half2 ramp( half2 min, half2 max, half2 value )
		{
		return saturate( ( value - min ) / ( max - min ) );
		}
		half3 ramp( half3 min, half3 max, half3 value )
		{
		return saturate( ( value - min ) / ( max - min ) );
		}
		half4 ramp( half4 min, half4 max, half4 value )
		{
		return saturate( ( value - min ) / ( max - min ) );
		}
		half rampns( half min, half max, half value )
		{
		return ( ( value - min ) / ( max - min ) );
		}
		half2 rampns( half2 min, half2 max, half2 value )
		{
		return ( ( value - min ) / ( max - min ) );
		}
		half3 rampns( half3 min, half3 max, half3 value )
		{
		return ( ( value - min ) / ( max - min ) );
		}
		half4 rampns( half4 min, half4 max, half4 value )
		{
		return ( ( value - min ) / ( max - min ) );
		}
		half3 quadFace( half3 pos, half2 uv, half3 up, half3 tangent, half2 scale )
		{
		scale.xy *= half2( uv.x - 0.5, 0.5 - uv.y );
		pos += tangent * scale.x;
		pos += up * scale.y;
		return pos;
		}
		half3 cameraFaceUp( half3 pos, half3 localUp, half2 uv, half2 scale, half3x4 cameraToWorldTranspose )
		{
		half3 tangent = half3( cameraToWorldTranspose[0][0], cameraToWorldTranspose[1][0], cameraToWorldTranspose[2][0] );
		half3 up = half3( cameraToWorldTranspose[0][1], cameraToWorldTranspose[1][1], cameraToWorldTranspose[2][1] );
		half dotUp = dot( localUp, up );
		half dotTangent = dot( localUp, tangent );
		half3 projUp = normalize( dotUp * up + dotTangent * tangent );
		half3 projTangent = normalize( -dotTangent * up + dotUp * tangent );
		return quadFace( pos, uv, projUp, projTangent, scale );
		}
		void tileUV( half2 uv, half particleId, half time, half speed, half numTiles, out half2 offsetUV, out half blend )
		{
		half t = particleId * 255 + time * speed;
		blend = frac( t );
		half4 tile = half4( t - blend, t + 1 - blend, uv.y, uv.y );
		tile /= numTiles;
		tile.xy = frac( tile.xy );
		tile.xy += tile.zw;
		offsetUV = tile.xy;
		}
		half3 sunset( half cosSunAngle, half3 nightTint )
		{
		half3 white     = half3( 1.0, 1.0, 1.0 ) * 1.3;
		half3 yellow    = half3( 1.0, 1.0, 0.5 ) * 1.2;
		half3 orange    = half3( 1.0, 0.7, 0.3 );
		half3 red       = half3( 1.0, 0.5, 0.5 );
		half t = ramp( 0.6, 1.0, cosSunAngle );
		half3 b0 = lerp( yellow, white, t );
		t = ramp( 0.2, 0.6, cosSunAngle );
		half3 b1 = lerp( orange, b0, t );
		t = ramp( -0.2, 0.2, cosSunAngle );
		half3 b2 = lerp( red, b1, t );
		t = ramp( -1.0, -0.2, cosSunAngle );
		half3 b3 = lerp( nightTint, b2, t );
		return b3;
		}
		half3 sunsetns( half cosSunAngle, half3 nightTint )
		{
		half3 white     = half3( 1.0, 1.0, 1.0 ) * 1.3;
		half3 yellow    = half3( 1.0, 1.0, 0.5 ) * 1.2;
		half3 orange    = half3( 1.0, 0.7, 0.3 );
		half3 red       = half3( 1.0, 0.5, 0.5 );
		half t = rampns( 0.6, 1.0, cosSunAngle );
		half3 b0 = lerp( yellow, white, t );
		t = rampns( 0.2, 0.6, cosSunAngle );
		half3 b1 = lerp( orange, b0, t );
		t = rampns( -0.2, 0.2, cosSunAngle );
		half3 b2 = lerp( red, b1, t );
		t = rampns( -1.0, -0.2, cosSunAngle );
		half3 b3 = lerp( nightTint, b2, t );
		return b3;
		}
		half3 volumeLightQuad( half3 color, half3 bottomColor, half2 uv, half3 pos, half3 offsetPos, half topBlend, half cosSunAngle, half3 sunDir )
		{
		color = lerp( color, color * bottomColor, uv.y * ( 1-topBlend ));
		half3 n = normalize( offsetPos - pos );
		half i0 = saturate( dot( sunDir, n )* 1.42 );
		half i1 = saturate( cosSunAngle );
		half intensity = lerp( i0, i1, topBlend*topBlend );
		color = lerp( color, color * intensity, 0.25 );
		return color;
		}
	endCode

	code
		const half alphaAmp         = 2.5;
		const half fogAmp           = 0.2;
		const half cameraFadeStart  = 100.0;
		const half cameraFadeEnd    = 200.0;
		const half glowScalar       = 7;
		half animBlendRate = customParams[0].x;
		half stripLength = customParams[0].y;
		half topFadeAmount = customParams[0].z;
		Current.texcoord<t0> = Current.color1;
		half2 uv = Current.texcoord<t0>.xy;
		half2 id = Current.texcoord<t0>.zw;
		half4 color = In.color;
		half planetRadius = terrainState.sphereParms.x;
		half waterHeight = terrainState.innerParms.w;
		half terrainHeight = In.position.w;
		half temperature = terraformValues.x;
		half3 cameraPos = half3( cameraToWorldTranspose[0][3], cameraToWorldTranspose[1][3], cameraToWorldTranspose[2][3] );
		half3 toCamera = cameraPos - In.position.xyz;
		half4 hPos = half4( In.position.xyz, 1 );
		half3 npos = normalize( In.position.xyz );
		half cameraDist = length( toCamera );
		half3 toCamNormal = toCamera / cameraDist;
		half topBlend = saturate( dot( npos, toCamNormal  ) );
		half topFade = ramp( 1.0f, 0.25f, topBlend * topFadeAmount );
		color.a *= topFade;
		half cameraFade = ramp( 150.0f, 1000.0f, cameraDist * (11 - 10 * topFadeAmount ));
		color.a *= cameraFade;
		half PdotV = dot( npos, worldCameraNormal );
		half nearFade = 350 < cameraDist ? 1 : 0;
		half backFade = -0.2 < PdotV ? 1 : 0;
		half2 scale = In.normal.w * 2 * backFade * nearFade;
		scale *= min( color.a * 60, 1 );
		half glow = saturate( waterHeight - terrainHeight );
		half cloudHeight = id.y * 40 - 10;
		half3 pos = In.position.xyz + cloudHeight;
		if ( cloudHeight <= 20 )
		{
		scale *= 0.7;
		pos -= npos * 20;
		}
		else
		{
		scale.x *= lerp( 0.9, 0.6, topBlend );
		scale.y *= lerp( 0.3, 0.6, topBlend );
		pos += npos * 10;
		}
		hPos.xyz = cameraFaceUp( pos, npos, uv, scale, cameraToWorldTranspose );
		half2 tile;
		half tileAnimBlend;
		tileUV( uv, id.y, gameInfo.x, animBlendRate, stripLength, tile, tileAnimBlend );
		half cosSunAngle = saturate( dot( npos.xyz, terrainState.vSunDir.xyz ) );
		half3 bottomColor = sunset( cosSunAngle, terrainState.nightLightTint.rgb );
		color.rgb = volumeLightQuad( color.rgb, bottomColor, uv, In.position.xyz, hPos.xyz, topBlend, cosSunAngle, terrainState.vSunDir.xyz );
		half cameraHeight = length( cameraPos );
		half cameraHeightFade = saturate( ( cameraHeight - planetRadius - cameraFadeStart ) / ( cameraFadeEnd - cameraFadeStart ) );
		color.a *= lerp( alphaAmp, 1, cameraHeightFade );
		glow *= saturate( temperature - 0.85 );
		glow *= glowScalar;
		half glowHeight = uv.y * glow;
		Current.position            = mul( hPos, worldToClip );
		Current.color               = color;
		Current.texcoord<t0>        = half4( uv.x, tile.x, uv.x, tile.y );
		Current.texcoord<t1>.xy     = half2( tileAnimBlend, topBlend );
		Current.texcoord<t1>.zw     = half2( glowHeight, 0 );
		Current.color.a             *= lerp( 1.1, 0.3, ( cloudHeight > 20 ) );
		half depth              = cameraDist;
		half3 normal            = npos;
		half atmoRadius         = terrainState.sphereParms.x + terrainState.sphereParms.z;
		half minFogDistance     = terrainState.fogParms.z;
		half4 position          = hPos;
		float  fogScale, fogStrength, term;
		float4 eyeVec;
		GetTerrainFogStrength( position.xyz, npos.xyz, ( terrainState.sphereParms.x + terrainState.sphereParms.z ), fogStrength, fogScale, term, eyeVec );
		fogStrength *= 0.6;
		Current.texcoord<t1>.w = fogStrength;
		Current.texcoord<t2> = half4( mul( toCamera, viewTransform ).xyz, cameraDist );
	endCode
end
