vertexFragment rocksVanillaFoggedVS
	input normal color color1 tangent position
	output position -texcoords 5 float4

	declareCode
		extern uniform float4 customParams[2];
		extern uniform float4 worldCameraPosition;
		extern uniform float3x4 cameraToWorldTranspose;
		extern uniform float4x4 worldToClip;
		extern uniform float4x3 cameraToWorld;
		extern uniform struct
		{
			float4 vSunDir;
			float4 nightLightTint;
			float4 nightLightColor;
			float4 duskLightColor;
			float4 dayLightColor;
			float4 nightShadowColor;
			float4 duskShadowColor;
			float4 dayShadowColor;
			float4 duskDawnStartEnd;
		} terrainLighting;
		extern uniform float4x4 viewTransform;
		extern uniform struct
		{
		float4 vSunDir;
		float4 waterColor;
		float4 innerParms;
		float4 vCamPos;
		float4 sphereParms;
		float4 camParms;
		float4 illumParms;
		float4 fogParms;
		float4 nightLightTint;
		float4 nightLightColor;
		float4 duskLightColor;
		float4 dayLightColor;
		float4 nightShadowColor;
		float4 duskShadowColor;
		float4 dayShadowColor;
		float4 duskDawnStartEnd;
		float4x4 viewTransform;
		} terrainState;
		extern uniform float4 foggingCPU;
		extern uniform struct
		{
		float4 vSunDir;
		float4 waterColor;
		float4 innerParms;
		float4 vCamPos;
		float4 sphereParms;
		float4 camParms;
		float4 illumParms;
		float4 fogParms;
		float4 nightLightTint;
		float4 nightLightColor;
		float4 duskLightColor;
		float4 dayLightColor;
		float4 nightShadowColor;
		float4 duskShadowColor;
		float4 dayShadowColor;
		float4 duskDawnStartEnd;
		float4x4 viewTransform;
		} terrainState;

		half ramp( half min, half max, half value )
		{
		return saturate( ( value - min ) / ( max - min ) );
		}
		half2 ramp( half2 min, half2 max, half2 value )
		{
		return saturate( ( value - min ) / ( max - min ) );
		}
		half3 ramp( half3 min, half3 max, half3 value )
		{
		return saturate( ( value - min ) / ( max - min ) );
		}
		half4 ramp( half4 min, half4 max, half4 value )
		{
		return saturate( ( value - min ) / ( max - min ) );
		}
		half3 quadFace( half3 pos, half2 uv, half3 up, half3 tangent, half scale )
		{
		pos += tangent * scale * (uv.x - 0.5);
		pos += up * scale * (0.5 - uv.y);
		return pos;
		}
		half3 quadFace( half3 pos, half2 uv, half3 up, half3 tangent, half2 scale )
		{
		pos += tangent * scale.x * (uv.x - 0.5);
		pos += up * scale.y * (0.5 - uv.y);
		return pos;
		}
		half3 cameraFace( half3 pos, half2 uv, half scale, half3x4 cameraToWorldTranspose )
		{
		half3 tangent = half3( cameraToWorldTranspose[0][0], cameraToWorldTranspose[1][0], cameraToWorldTranspose[2][0] );
		half3 up = half3( cameraToWorldTranspose[0][1], cameraToWorldTranspose[1][1], cameraToWorldTranspose[2][1] );
		return quadFace( pos, uv, up, tangent, scale );
		}
		half3 cameraFace( half3 pos, half2 uv, half2 scale, half3x4 cameraToWorldTranspose )
		{
		half3 tangent = half3( cameraToWorldTranspose[0][0], cameraToWorldTranspose[1][0], cameraToWorldTranspose[2][0] );
		half3 up = half3( cameraToWorldTranspose[0][1], cameraToWorldTranspose[1][1], cameraToWorldTranspose[2][1] );
		return quadFace( pos, uv, up, tangent, scale );
		}
		half3 cameraFaceUp( half3 pos, half3 localUp, half2 uv, half scale, half3x4 cameraToWorldTranspose )
		{
		half3 tangent = half3( cameraToWorldTranspose[0][0], cameraToWorldTranspose[1][0], cameraToWorldTranspose[2][0] );
		half3 up = half3( cameraToWorldTranspose[0][1], cameraToWorldTranspose[1][1], cameraToWorldTranspose[2][1] );
		half dotUp = dot( localUp, up );
		half dotTangent = dot( localUp, tangent );
		half3 projUp = normalize( dotUp * up + dotTangent * tangent );
		half3 projTangent = normalize( -dotTangent * up + dotUp * tangent );
		return quadFace( pos, uv, projUp, projTangent, scale );
		}
		half3 cameraFaceUp( half3 pos, half3 localUp, half2 uv, half2 scale, half3x4 cameraToWorldTranspose )
		{
		half3 tangent = half3( cameraToWorldTranspose[0][0], cameraToWorldTranspose[1][0], cameraToWorldTranspose[2][0] );
		half3 up = half3( cameraToWorldTranspose[0][1], cameraToWorldTranspose[1][1], cameraToWorldTranspose[2][1] );
		half dotUp = dot( localUp, up );
		half dotTangent = dot( localUp, tangent );
		half3 projUp = normalize( dotUp * up + dotTangent * tangent );
		half3 projTangent = normalize( -dotTangent * up + dotUp * tangent );
		return quadFace( pos, uv, projUp, projTangent, scale );
		}
		void tileUV( half2 uv, half particleId, half time, half speed, half numTiles, out half2 offsetUV, out half blend )
		{
		half t = particleId * 255 + time * speed;
		blend = frac( t );
		half4 tile = half4( t - blend, t + 1 - blend, uv.y, uv.y );
		tile /= numTiles;
		tile.xy = frac( tile.xy );
		tile.xy += tile.zw;
		offsetUV = tile.xy;
		}
		half3 sunset( half cosSunAngle, half3 nightTint )
		{
		half3 white     = half3( 1.0, 1.0, 1.0 ) * 1.3;
		half3 yellow    = half3( 1.0, 1.0, 0.5 ) * 1.2;
		half3 orange    = half3( 1.0, 0.7, 0.3 );
		half3 red       = half3( 1.0, 0.5, 0.5 );
		half t = ramp( 0.6, 1.0, cosSunAngle );
		half3 b0 = lerp( yellow, white, t );
		t = ramp( 0.2, 0.6, cosSunAngle );
		half3 b1 = lerp( orange, b0, t );
		t = ramp( -0.2, 0.2, cosSunAngle );
		half3 b2 = lerp( red, b1, t );
		t = ramp( -1.0, -0.2, cosSunAngle );
		half3 b3 = lerp( nightTint, b2, t );
		return b3;
		}
		half3 volumeLightQuad( half3 color, half3 bottomColor, half2 uv, half3 pos, half3 offsetPos, half topBlend, half cosSunAngle, half3 sunDir )
		{
		color = lerp( color, color * bottomColor, uv.y * ( 1-topBlend ));
		half3 n = normalize( offsetPos - pos );
		half i0 = saturate( dot( sunDir, n )* 1.42 );
		half i1 = saturate( cosSunAngle );
		half intensity = lerp( i0, i1, topBlend*topBlend );
		color = lerp( color, color * intensity, 0.25 );
		return color;
		}
		float GetInScatterTerminator( float3 vNorm, float3 vSunDir, float cutoff )
		{
		float dp = dot( vNorm, vSunDir );
		dp = ( dp > cutoff ) ? 1.0 : max( 0, dp + cutoff )/(2 * cutoff);
		return dp;
		}
		void GetTerrainFogStrength( float3 position, float3 normal, float atmoRadius, out float fogStrength, out float fogScale, out float term, out float4 eyeVec )
		{
		float4 vCamPos = terrainState.vCamPos;
		float3 vNormCamToVert = position - vCamPos;
		float cameraDistance = length( vNormCamToVert );
		vNormCamToVert = vNormCamToVert/cameraDistance;
		eyeVec.xyz = vNormCamToVert;
		eyeVec.w = cameraDistance;
		float b = dot( -vNormCamToVert, position.xyz );
		float c = dot( position.xyz, position.xyz ) - atmoRadius*atmoRadius;
		float d = b*b-c;
		float minFogDistance = terrainState.fogParms.z;
		float t = -b + sqrt(d);
		float fogDist = max( t, 0 );
		fogDist = min( t, cameraDistance );
		fogDist = max( 0, fogDist-minFogDistance );
		float density = terrainState.fogParms.x;
		fogStrength = 1.0 - exp( density * fogDist );
		term = GetInScatterTerminator( normal, terrainState.vSunDir.xyz, terrainState.vSunDir.w );
		fogStrength *= term;
		fogScale = terrainState.fogParms.y;
		}
		// the incomming color should be "In.color * 2"
		void rocksColorAndFade( half id, half startFade, half endFade, half cameraDistance, half2 uv, in out half4 color, out half fade )
		{
		// fade out term
		fade = saturate( (endFade - cameraDistance) / (endFade - startFade) );
		// use the paritcle id to generate some "noise"
		half rfade = id * 0.5 + 0.5;
		// add some noise to the transition
		fade *= rfade;
		// fade out alpha
		color.a *= fade;
		}
		half rocksFadeScale( half scaled, half fade, half cameraDistance, half startScale, half endScale, half scaleFactor )
		{
		// 1 -> scaleFactor
		scaled *= lerp( 1, scaleFactor, saturate( (cameraDistance - startScale) / (endScale - startScale) ) );
		// change the size based on the fade
		scaled *= ( fade * 0.5 + 0.5 );
		// return the value
		return scaled;
		}
		void rocksLighting( half3 pos, out half3 lightColor, out half3 lightBlend )
		{
		// Stock terrain lighting
		half3 shadowColor;
		half3 npos = normalize( pos );
		EvaluateVertexLighting(
		npos.xyz,
		terrainLighting.vSunDir.xyz,
		terrainLighting.duskDawnStartEnd,
		terrainLighting.dayLightColor.xyz,
		terrainLighting.dayShadowColor.xyz,
		terrainLighting.duskLightColor.xyz,
		terrainLighting.duskShadowColor.xyz,
		terrainLighting.nightLightColor.xyz,
		terrainLighting.nightShadowColor.xyz,
		lightBlend,
		lightColor,
		shadowColor );
		lightColor = TerrainVertexLighting( terrainLighting.vSunDir.xyz, npos, shadowColor, lightColor, lightBlend );
		}
		void rocksLightingLow( half3 pos, out half3 lightColor, out half3 lightBlend )
		{
		// Stock terrain lighting
		half3 shadowColor;
		half3 npos = normalize( pos );
		EvaluateVertexLighting(
		npos.xyz,
		terrainLighting.vSunDir.xyz,
		terrainLighting.duskDawnStartEnd,
		terrainLighting.dayLightColor.xyz,
		terrainLighting.dayShadowColor.xyz,
		terrainLighting.duskLightColor.xyz,
		terrainLighting.duskShadowColor.xyz,
		terrainLighting.nightLightColor.xyz,
		terrainLighting.nightShadowColor.xyz,
		lightBlend,
		lightColor,
		shadowColor );
		lightColor = TerrainVertexLightingLow( terrainLighting.vSunDir.xyz, npos, shadowColor, lightColor, lightBlend );
		}
		half rocksCell( half id, half v )
		{
		int cell = floor( id * 7.999 );
		v += cell;
		v /= 8;
		return v;
		}
	endCode

	code
		// tuneables
		const half size            = 1.5f;
		// custom parameters
		half startFade = customParams[0].x;
		half endFade = customParams[0].y;
		// this is unused, but we are keeping it here so the custom parameters match grass
		// half tilt = customParams[0].z * 3.1415926535897932384626433832795 / 180.0;
		half startScale = customParams[1].x;
		half endScale = customParams[1].y;
		half scaleFactor = customParams[1].z;
		// load texcoord 0 with our texcoords that come in color1
		Current.texcoord<t0> = Current.color1;
		// aliases
		half scale = In.normal.w;
		half id = Current.texcoord<t0>.w;
		half2 uv = Current.texcoord<t0>.xy;
		// start with the size that was sent up in the vertex
		half scaled = In.normal.w * size;
		// get the vector from the position to the camera
		half3 toCamera = worldCameraPosition - Current.position.xyz;
		// calculate the distance from the camera
		half cameraDistance = length( toCamera );
		// calculate the color and fade values
		half4 color = In.color.rgba * 2;
		half fade;
		rocksColorAndFade( Current.texcoord<t0>.w, startFade, endFade, cameraDistance, uv, color, fade );
		// fade the rocks scale
		scaled = rocksFadeScale( scaled, fade, cameraDistance, startScale, endScale, scaleFactor );
		// calculate the lighting
		half3 lightColor, lightBlend;
		rocksLighting( In.position.xyz, lightColor, lightBlend );
		// get the normalized position
		half3 npos = normalize( In.position.xyz );
		// calculate the night light blend
		half nightLumBlend	= terrainLighting.nightLightTint.a * lightBlend.z;
		// output
		Current.position.xyz        = cameraFaceUp( In.position.xyz, npos, uv, scaled, cameraToWorldTranspose );
		Current.position.w          = 1;
		Current.texcoord<t0>.y      = rocksCell( id, Current.texcoord<t0>.y );
		Current.texcoord<t0>.zw     = 0;                                                                            // z is unused
		Current.texcoord<t1>		= float4( color.rgb * fade * lightColor.rgb, color.a );
		Current.texcoord<t2>		= float4( color.rgb * ( 1 - fade ) * lightColor.rgb, 0 );
		Current.texcoord<t3>.rgb	= terrainLighting.nightLightTint.rgb * nightLumBlend * 0.5;
		Current.texcoord<t3>.a		= nightLumBlend;
		Current.texcoord<t4>        = 0;
		float  fogScale, fogStrength, term;
		float4 eyeVec;
		GetTerrainFogStrength( In.position.xyz, npos.xyz, ( terrainState.sphereParms.x + terrainState.sphereParms.z ), fogStrength, fogScale, term, eyeVec );
		float sunDrop = saturate( dot( npos, terrainState.vSunDir.xyz ) + 0.95 );
		Current.texcoord<t0>.w = sunDrop;
		Current.texcoord<t4> = half4( mul( toCamera, viewTransform ).xyz, fogStrength );
	endCode
end
