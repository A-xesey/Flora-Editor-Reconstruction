pixelFragment shLightingGlossy25
	input color -texcoords 3

	declareCode
		extern uniform float4 shCoeffs[25];
		extern uniform struct { float4 mDir; float4 mColor; } dirLightsWorld[1];
		extern uniform float4 worldCameraDirection;

		const static float kSH_A1 = 2.0 / 3.0;
		const static float kSH_A2 = 1.0 / 4.0;
		const static float kSH_A3 = 0;
		const static float kSH_A4 = -1.0 / 24.0;
		const static float kDefaultGloss = 0.35;
		const static float kGlossyMax    = 0.75; // threshold at which glossy maxes out
		const static float kCelOutlineThreshold        = 0.25;
		const static float kCelOutlineThresholdRange   = 0.075;
		const static float kCelStrength                = 0.3;
		const static float kSpecExponentMaxValue = 60.0;
		const static bool kSaveInstructions = false;
		float3 SHLightingGlossy25
		(
		float3 colorIn,
		float3 normal,
		float3 shColorDiff,
		float3 shColorSpec,
		float  glossyStrength,
		float  specE         = 1,
		float  specStrength  = 0,
		bool   translucency  = false
		)
		{
		float3 x0;
		float3 reflectedNormal = reflect(worldCameraDirection, normal);
		if (translucency)
		{
		x0 = -normal;
		}
		else
		{
		x0 = reflectedNormal;
		}
		float3 x1 = x0 * x0;
		float3 x2 = x0 * x0.yzx;
		shColorSpec += shCoeffs[ 9].xyz * (3 * x1.x - x1.y) * x0.y;
		shColorSpec += shCoeffs[10].xyz * x1.x * x0.z;
		shColorSpec += shCoeffs[11].xyz * (5 * x1.z - 1) * x0.y;
		shColorSpec += shCoeffs[12].xyz * (5 * x1.z - 3) * x0.z;
		shColorSpec += shCoeffs[13].xyz * (5 * x1.z - 1) * x0.x;
		shColorSpec += shCoeffs[14].xyz * (x1.x - x1.y) * x0.z;
		shColorSpec += shCoeffs[15].xyz * (x1.x - 3 * x1.y) * x0.x;
		shColorSpec += shCoeffs[16].xyz * (x1.x - x1.y) * x2.x;
		shColorSpec += shCoeffs[17].xyz * (3 * x1.x - x1.y) * x2.y;
		shColorSpec += shCoeffs[18].xyz * (7 * x1.z - 1) * x2.x;
		shColorSpec += shCoeffs[19].xyz * (7 * x1.z - 3) * x2.y;
		shColorSpec += shCoeffs[20].xyz * (3 - 30 * x1.z + 35 * x1.z * x1.z);
		shColorSpec += shCoeffs[21].xyz * (7 * x1.z - 3) * x2.z;
		shColorSpec += shCoeffs[22].xyz * (7 * x1.z - 1) * (x1.x - x1.y);
		shColorSpec += shCoeffs[23].xyz * (x1.x - 3 * x1.y) * x2.z;
		shColorSpec += shCoeffs[24].xyz * (x1.x * x1.x + x1.y * x1.y - 6 * x1.x * x1.y);
		if (translucency)
		{
		shColorSpec *= glossyStrength;
		}
		else
		{
		float s = glossyStrength;
		shColorDiff *= 1 - s;
		shColorSpec *= s;
		}
		colorIn *= (shColorSpec + shColorDiff);
		float nDotR = saturate(dot(reflectedNormal, dirLightsWorld[0].mDir));
		float spec1 = pow(nDotR, specE);
		float nDotL = dot(normal, dirLightsWorld[0].mDir);
		float rDotL = dot(reflectedNormal, dirLightsWorld[0].mDir);
		float spec2 = lit(nDotL, rDotL, specE).z;
		colorIn += spec1 * specStrength * dirLightsWorld[0].mColor;
		return colorIn;
		}
	endCode

	code
		float3 normal      = In.texcoord<t0>;
		float4 shColorDiff = In.texcoord<t1>;
		float4 shColorSpec = In.texcoord<t2>;
		Current.color.rgb = SHLightingGlossy25(Current.color.rgb, normal, shColorDiff, shColorSpec, kDefaultGloss, 20, 0);
	endCode
end
